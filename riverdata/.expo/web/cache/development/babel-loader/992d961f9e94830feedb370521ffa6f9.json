{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"radius\", \"maxZoom\", \"minZoom\", \"minPoints\", \"extent\", \"nodeSize\", \"children\", \"onClusterPress\", \"onRegionChangeComplete\", \"onMarkersChange\", \"preserveClusterPressBehavior\", \"clusteringEnabled\", \"clusterColor\", \"clusterTextColor\", \"clusterFontFamily\", \"spiderLineColor\", \"layoutAnimationConf\", \"animationEnabled\", \"renderCluster\", \"tracksViewChanges\", \"spiralEnabled\", \"superClusterRef\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport React, { memo, useState, useEffect, useMemo, useRef, forwardRef } from \"react\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport LayoutAnimation from \"react-native-web/dist/exports/LayoutAnimation\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport MapView, { Marker, Polyline } from \"react-native-maps\";\nimport SuperCluster from \"supercluster\";\nimport ClusterMarker from \"./ClusteredMarker\";\nimport { isMarker, markerToGeoJSONFeature, calculateBBox, returnMapZoom, generateSpiral } from \"./helpers\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nvar ClusteredMapView = forwardRef(function (_ref, _ref3) {\n  var radius = _ref.radius,\n    maxZoom = _ref.maxZoom,\n    minZoom = _ref.minZoom,\n    minPoints = _ref.minPoints,\n    extent = _ref.extent,\n    nodeSize = _ref.nodeSize,\n    children = _ref.children,\n    onClusterPress = _ref.onClusterPress,\n    onRegionChangeComplete = _ref.onRegionChangeComplete,\n    onMarkersChange = _ref.onMarkersChange,\n    preserveClusterPressBehavior = _ref.preserveClusterPressBehavior,\n    clusteringEnabled = _ref.clusteringEnabled,\n    clusterColor = _ref.clusterColor,\n    clusterTextColor = _ref.clusterTextColor,\n    clusterFontFamily = _ref.clusterFontFamily,\n    spiderLineColor = _ref.spiderLineColor,\n    layoutAnimationConf = _ref.layoutAnimationConf,\n    animationEnabled = _ref.animationEnabled,\n    renderCluster = _ref.renderCluster,\n    tracksViewChanges = _ref.tracksViewChanges,\n    spiralEnabled = _ref.spiralEnabled,\n    superClusterRef = _ref.superClusterRef,\n    restProps = _objectWithoutProperties(_ref, _excluded);\n  var _useState = useState([]),\n    _useState2 = _slicedToArray(_useState, 2),\n    markers = _useState2[0],\n    updateMarkers = _useState2[1];\n  var _useState3 = useState([]),\n    _useState4 = _slicedToArray(_useState3, 2),\n    spiderMarkers = _useState4[0],\n    updateSpiderMarker = _useState4[1];\n  var _useState5 = useState([]),\n    _useState6 = _slicedToArray(_useState5, 2),\n    otherChildren = _useState6[0],\n    updateChildren = _useState6[1];\n  var _useState7 = useState(null),\n    _useState8 = _slicedToArray(_useState7, 2),\n    superCluster = _useState8[0],\n    setSuperCluster = _useState8[1];\n  var _useState9 = useState(restProps.region || restProps.initialRegion),\n    _useState10 = _slicedToArray(_useState9, 2),\n    currentRegion = _useState10[0],\n    updateRegion = _useState10[1];\n  var _useState11 = useState(false),\n    _useState12 = _slicedToArray(_useState11, 2),\n    isSpiderfier = _useState12[0],\n    updateSpiderfier = _useState12[1];\n  var _useState13 = useState(null),\n    _useState14 = _slicedToArray(_useState13, 2),\n    clusterChildren = _useState14[0],\n    updateClusterChildren = _useState14[1];\n  var mapRef = useRef();\n  var propsChildren = useMemo(function () {\n    return React.Children.toArray(children);\n  }, [children]);\n  useEffect(function () {\n    var rawData = [];\n    var otherChildren = [];\n    if (!clusteringEnabled) {\n      updateSpiderMarker([]);\n      updateMarkers([]);\n      updateChildren(propsChildren);\n      setSuperCluster(null);\n      return;\n    }\n    propsChildren.forEach(function (child, index) {\n      if (isMarker(child)) {\n        rawData.push(markerToGeoJSONFeature(child, index));\n      } else {\n        otherChildren.push(child);\n      }\n    });\n    var superCluster = new SuperCluster({\n      radius: radius,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      minPoints: minPoints,\n      extent: extent,\n      nodeSize: nodeSize\n    });\n    superCluster.load(rawData);\n    var bBox = calculateBBox(currentRegion);\n    var zoom = returnMapZoom(currentRegion, bBox, minZoom);\n    var markers = superCluster.getClusters(bBox, zoom);\n    updateMarkers(markers);\n    updateChildren(otherChildren);\n    setSuperCluster(superCluster);\n    superClusterRef.current = superCluster;\n  }, [propsChildren, clusteringEnabled]);\n  useEffect(function () {\n    if (!spiralEnabled) return;\n    if (isSpiderfier && markers.length > 0) {\n      var allSpiderMarkers = [];\n      var spiralChildren = [];\n      markers.map(function (marker, i) {\n        if (marker.properties.cluster) {\n          spiralChildren = superCluster.getLeaves(marker.properties.cluster_id, Infinity);\n        }\n        var positions = generateSpiral(marker, spiralChildren, markers, i);\n        allSpiderMarkers.push.apply(allSpiderMarkers, _toConsumableArray(positions));\n      });\n      updateSpiderMarker(allSpiderMarkers);\n    } else {\n      updateSpiderMarker([]);\n    }\n  }, [isSpiderfier, markers]);\n  var _onRegionChangeComplete = function _onRegionChangeComplete(region) {\n    if (superCluster && region) {\n      var bBox = calculateBBox(region);\n      var zoom = returnMapZoom(region, bBox, minZoom);\n      var _markers = superCluster.getClusters(bBox, zoom);\n      if (animationEnabled && Platform.OS === \"ios\") {\n        LayoutAnimation.configureNext(layoutAnimationConf);\n      }\n      if (zoom >= 18 && _markers.length > 0 && clusterChildren) {\n        if (spiralEnabled) updateSpiderfier(true);\n      } else {\n        if (spiralEnabled) updateSpiderfier(false);\n      }\n      updateMarkers(_markers);\n      onMarkersChange(_markers);\n      onRegionChangeComplete(region, _markers);\n      updateRegion(region);\n    } else {\n      onRegionChangeComplete(region);\n    }\n  };\n  var _onClusterPress = function _onClusterPress(cluster) {\n    return function () {\n      var children = superCluster.getLeaves(cluster.id, Infinity);\n      updateClusterChildren(children);\n      if (preserveClusterPressBehavior) {\n        onClusterPress(cluster, children);\n        return;\n      }\n      var coordinates = children.map(function (_ref2) {\n        var geometry = _ref2.geometry;\n        return {\n          latitude: geometry.coordinates[1],\n          longitude: geometry.coordinates[0]\n        };\n      });\n      mapRef.current.fitToCoordinates(coordinates, {\n        edgePadding: restProps.edgePadding\n      });\n      onClusterPress(cluster, children);\n    };\n  };\n  return _jsxs(MapView, _objectSpread(_objectSpread({}, restProps), {}, {\n    ref: function ref(map) {\n      mapRef.current = map;\n      if (_ref3) _ref3.current = map;\n      restProps.mapRef(map);\n    },\n    onRegionChangeComplete: _onRegionChangeComplete,\n    children: [markers.map(function (marker) {\n      return marker.properties.point_count === 0 ? propsChildren[marker.properties.index] : !isSpiderfier ? renderCluster ? renderCluster(_objectSpread({\n        onPress: _onClusterPress(marker),\n        clusterColor: clusterColor,\n        clusterTextColor: clusterTextColor,\n        clusterFontFamily: clusterFontFamily\n      }, marker)) : _jsx(ClusterMarker, _objectSpread(_objectSpread({}, marker), {}, {\n        onPress: _onClusterPress(marker),\n        clusterColor: restProps.selectedClusterId === marker.id ? restProps.selectedClusterColor : clusterColor,\n        clusterTextColor: clusterTextColor,\n        clusterFontFamily: clusterFontFamily,\n        tracksViewChanges: tracksViewChanges\n      }), \"cluster-\" + marker.id) : null;\n    }), otherChildren, spiderMarkers.map(function (marker) {\n      return propsChildren[marker.index] ? React.cloneElement(propsChildren[marker.index], {\n        coordinate: _objectSpread({}, marker)\n      }) : null;\n    }), spiderMarkers.map(function (marker, index) {\n      return _jsx(Polyline, {\n        coordinates: [marker.centerPoint, marker, marker.centerPoint],\n        strokeColor: spiderLineColor,\n        strokeWidth: 1\n      }, index);\n    })]\n  }));\n});\nClusteredMapView.defaultProps = {\n  clusteringEnabled: true,\n  spiralEnabled: true,\n  animationEnabled: true,\n  preserveClusterPressBehavior: false,\n  layoutAnimationConf: LayoutAnimation.Presets.spring,\n  tracksViewChanges: false,\n  radius: Dimensions.get(\"window\").width * 0.06,\n  maxZoom: 20,\n  minZoom: 1,\n  minPoints: 2,\n  extent: 512,\n  nodeSize: 64,\n  edgePadding: {\n    top: 50,\n    left: 50,\n    right: 50,\n    bottom: 50\n  },\n  clusterColor: \"#00B386\",\n  clusterTextColor: \"#FFFFFF\",\n  spiderLineColor: \"#FF0000\",\n  onRegionChangeComplete: function onRegionChangeComplete() {},\n  onClusterPress: function onClusterPress() {},\n  onMarkersChange: function onMarkersChange() {},\n  superClusterRef: {},\n  mapRef: function mapRef() {}\n};\nexport default memo(ClusteredMapView);","map":{"version":3,"names":["React","memo","useState","useEffect","useMemo","useRef","forwardRef","MapView","Marker","Polyline","SuperCluster","ClusterMarker","isMarker","markerToGeoJSONFeature","calculateBBox","returnMapZoom","generateSpiral","ClusteredMapView","ref","radius","maxZoom","minZoom","minPoints","extent","nodeSize","children","onClusterPress","onRegionChangeComplete","onMarkersChange","preserveClusterPressBehavior","clusteringEnabled","clusterColor","clusterTextColor","clusterFontFamily","spiderLineColor","layoutAnimationConf","animationEnabled","renderCluster","tracksViewChanges","spiralEnabled","superClusterRef","restProps","markers","updateMarkers","spiderMarkers","updateSpiderMarker","otherChildren","updateChildren","superCluster","setSuperCluster","region","initialRegion","currentRegion","updateRegion","isSpiderfier","updateSpiderfier","clusterChildren","updateClusterChildren","mapRef","propsChildren","Children","toArray","rawData","forEach","child","index","push","load","bBox","zoom","getClusters","current","length","allSpiderMarkers","spiralChildren","map","marker","i","properties","cluster","getLeaves","cluster_id","Infinity","positions","_onRegionChangeComplete","Platform","OS","LayoutAnimation","configureNext","_onClusterPress","id","coordinates","geometry","latitude","longitude","fitToCoordinates","edgePadding","point_count","onPress","selectedClusterId","selectedClusterColor","cloneElement","coordinate","centerPoint","defaultProps","Presets","spring","Dimensions","get","width","top","left","right","bottom"],"sources":["C:/Users/subte/RD2/riverdata/riverdata/node_modules/react-native-map-clustering/lib/ClusteredMapView.js"],"sourcesContent":["import React, {\n  memo,\n  useState,\n  useEffect,\n  useMemo,\n  useRef,\n  forwardRef,\n} from \"react\";\nimport { Dimensions, LayoutAnimation, Platform } from \"react-native\";\nimport MapView, { Marker, Polyline } from \"react-native-maps\";\nimport SuperCluster from \"supercluster\";\nimport ClusterMarker from \"./ClusteredMarker\";\nimport {\n  isMarker,\n  markerToGeoJSONFeature,\n  calculateBBox,\n  returnMapZoom,\n  generateSpiral,\n} from \"./helpers\";\n\nconst ClusteredMapView = forwardRef(\n  (\n    {\n      radius,\n      maxZoom,\n      minZoom,\n      minPoints,\n      extent,\n      nodeSize,\n      children,\n      onClusterPress,\n      onRegionChangeComplete,\n      onMarkersChange,\n      preserveClusterPressBehavior,\n      clusteringEnabled,\n      clusterColor,\n      clusterTextColor,\n      clusterFontFamily,\n      spiderLineColor,\n      layoutAnimationConf,\n      animationEnabled,\n      renderCluster,\n      tracksViewChanges,\n      spiralEnabled,\n      superClusterRef,\n      ...restProps\n    },\n    ref\n  ) => {\n    const [markers, updateMarkers] = useState([]);\n    const [spiderMarkers, updateSpiderMarker] = useState([]);\n    const [otherChildren, updateChildren] = useState([]);\n    const [superCluster, setSuperCluster] = useState(null);\n    const [currentRegion, updateRegion] = useState(\n      restProps.region || restProps.initialRegion\n    );\n\n    const [isSpiderfier, updateSpiderfier] = useState(false);\n    const [clusterChildren, updateClusterChildren] = useState(null);\n    const mapRef = useRef();\n\n    const propsChildren = useMemo(() => React.Children.toArray(children), [\n      children,\n    ]);\n\n    useEffect(() => {\n      const rawData = [];\n      const otherChildren = [];\n\n      if (!clusteringEnabled) {\n        updateSpiderMarker([]);\n        updateMarkers([]);\n        updateChildren(propsChildren);\n        setSuperCluster(null);\n        return;\n      }\n\n      propsChildren.forEach((child, index) => {\n        if (isMarker(child)) {\n          rawData.push(markerToGeoJSONFeature(child, index));\n        } else {\n          otherChildren.push(child);\n        }\n      });\n\n      const superCluster = new SuperCluster({\n        radius,\n        maxZoom,\n        minZoom,\n        minPoints,\n        extent,\n        nodeSize,\n      });\n\n      superCluster.load(rawData);\n\n      const bBox = calculateBBox(currentRegion);\n      const zoom = returnMapZoom(currentRegion, bBox, minZoom);\n      const markers = superCluster.getClusters(bBox, zoom);\n\n      updateMarkers(markers);\n      updateChildren(otherChildren);\n      setSuperCluster(superCluster);\n\n      superClusterRef.current = superCluster;\n    }, [propsChildren, clusteringEnabled]);\n\n    useEffect(() => {\n      if (!spiralEnabled) return;\n\n      if (isSpiderfier && markers.length > 0) {\n        let allSpiderMarkers = [];\n        let spiralChildren = [];\n        markers.map((marker, i) => {\n          if (marker.properties.cluster) {\n            spiralChildren = superCluster.getLeaves(\n              marker.properties.cluster_id,\n              Infinity\n            );\n          }\n          let positions = generateSpiral(marker, spiralChildren, markers, i);\n          allSpiderMarkers.push(...positions);\n        });\n\n        updateSpiderMarker(allSpiderMarkers);\n      } else {\n        updateSpiderMarker([]);\n      }\n    }, [isSpiderfier, markers]);\n\n    const _onRegionChangeComplete = (region) => {\n      if (superCluster && region) {\n        const bBox = calculateBBox(region);\n        const zoom = returnMapZoom(region, bBox, minZoom);\n        const markers = superCluster.getClusters(bBox, zoom);\n        if (animationEnabled && Platform.OS === \"ios\") {\n          LayoutAnimation.configureNext(layoutAnimationConf);\n        }\n        if (zoom >= 18 && markers.length > 0 && clusterChildren) {\n          if (spiralEnabled) updateSpiderfier(true);\n        } else {\n          if (spiralEnabled) updateSpiderfier(false);\n        }\n        updateMarkers(markers);\n        onMarkersChange(markers);\n        onRegionChangeComplete(region, markers);\n        updateRegion(region);\n      } else {\n        onRegionChangeComplete(region);\n      }\n    };\n\n    const _onClusterPress = (cluster) => () => {\n      const children = superCluster.getLeaves(cluster.id, Infinity);\n      updateClusterChildren(children);\n\n      if (preserveClusterPressBehavior) {\n        onClusterPress(cluster, children);\n        return;\n      }\n\n      const coordinates = children.map(({ geometry }) => ({\n        latitude: geometry.coordinates[1],\n        longitude: geometry.coordinates[0],\n      }));\n\n      mapRef.current.fitToCoordinates(coordinates, {\n        edgePadding: restProps.edgePadding,\n      });\n\n      onClusterPress(cluster, children);\n    };\n\n    return (\n      <MapView\n        {...restProps}\n        ref={(map) => {\n          mapRef.current = map;\n          if (ref) ref.current = map;\n          restProps.mapRef(map);\n        }}\n        onRegionChangeComplete={_onRegionChangeComplete}\n      >\n        {markers.map((marker) =>\n          marker.properties.point_count === 0 ? (\n            propsChildren[marker.properties.index]\n          ) : !isSpiderfier ? (\n            renderCluster ? (\n              renderCluster({\n                onPress: _onClusterPress(marker),\n                clusterColor,\n                clusterTextColor,\n                clusterFontFamily,\n                ...marker,\n              })\n            ) : (\n              <ClusterMarker\n                key={`cluster-${marker.id}`}\n                {...marker}\n                onPress={_onClusterPress(marker)}\n                clusterColor={\n                  restProps.selectedClusterId === marker.id\n                    ? restProps.selectedClusterColor\n                    : clusterColor\n                }\n                clusterTextColor={clusterTextColor}\n                clusterFontFamily={clusterFontFamily}\n                tracksViewChanges={tracksViewChanges}\n              />\n            )\n          ) : null\n        )}\n        {otherChildren}\n        {spiderMarkers.map((marker) => {\n          return propsChildren[marker.index]\n            ? React.cloneElement(propsChildren[marker.index], {\n                coordinate: { ...marker },\n              })\n            : null;\n        })}\n        {spiderMarkers.map((marker, index) => (\n          <Polyline\n            key={index}\n            coordinates={[marker.centerPoint, marker, marker.centerPoint]}\n            strokeColor={spiderLineColor}\n            strokeWidth={1}\n          />\n        ))}\n      </MapView>\n    );\n  }\n);\n\nClusteredMapView.defaultProps = {\n  clusteringEnabled: true,\n  spiralEnabled: true,\n  animationEnabled: true,\n  preserveClusterPressBehavior: false,\n  layoutAnimationConf: LayoutAnimation.Presets.spring,\n  tracksViewChanges: false,\n  // SuperCluster parameters\n  radius: Dimensions.get(\"window\").width * 0.06,\n  maxZoom: 20,\n  minZoom: 1,\n  minPoints: 2,\n  extent: 512,\n  nodeSize: 64,\n  // Map parameters\n  edgePadding: { top: 50, left: 50, right: 50, bottom: 50 },\n  // Cluster styles\n  clusterColor: \"#00B386\",\n  clusterTextColor: \"#FFFFFF\",\n  spiderLineColor: \"#FF0000\",\n  // Callbacks\n  onRegionChangeComplete: () => {},\n  onClusterPress: () => {},\n  onMarkersChange: () => {},\n  superClusterRef: {},\n  mapRef: () => {},\n};\n\nexport default memo(ClusteredMapView);\n"],"mappings":";;;;;;;AAAA,OAAOA,KAAK,IACVC,IAAI,EACJC,QAAQ,EACRC,SAAS,EACTC,OAAO,EACPC,MAAM,EACNC,UAAU,QACL,OAAO;AAAC;AAAA;AAAA;AAEf,OAAOC,OAAO,IAAIC,MAAM,EAAEC,QAAQ,QAAQ,mBAAmB;AAC7D,OAAOC,YAAY,MAAM,cAAc;AACvC,OAAOC,aAAa;AACpB,SACEC,QAAQ,EACRC,sBAAsB,EACtBC,aAAa,EACbC,aAAa,EACbC,cAAc;AACG;AAAA;AAEnB,IAAMC,gBAAgB,GAAGX,UAAU,CACjC,gBA0BEY,KAAG,EACA;EAAA,IAzBDC,MAAM,QAANA,MAAM;IACNC,OAAO,QAAPA,OAAO;IACPC,OAAO,QAAPA,OAAO;IACPC,SAAS,QAATA,SAAS;IACTC,MAAM,QAANA,MAAM;IACNC,QAAQ,QAARA,QAAQ;IACRC,QAAQ,QAARA,QAAQ;IACRC,cAAc,QAAdA,cAAc;IACdC,sBAAsB,QAAtBA,sBAAsB;IACtBC,eAAe,QAAfA,eAAe;IACfC,4BAA4B,QAA5BA,4BAA4B;IAC5BC,iBAAiB,QAAjBA,iBAAiB;IACjBC,YAAY,QAAZA,YAAY;IACZC,gBAAgB,QAAhBA,gBAAgB;IAChBC,iBAAiB,QAAjBA,iBAAiB;IACjBC,eAAe,QAAfA,eAAe;IACfC,mBAAmB,QAAnBA,mBAAmB;IACnBC,gBAAgB,QAAhBA,gBAAgB;IAChBC,aAAa,QAAbA,aAAa;IACbC,iBAAiB,QAAjBA,iBAAiB;IACjBC,aAAa,QAAbA,aAAa;IACbC,eAAe,QAAfA,eAAe;IACZC,SAAS;EAId,gBAAiCvC,QAAQ,CAAC,EAAE,CAAC;IAAA;IAAtCwC,OAAO;IAAEC,aAAa;EAC7B,iBAA4CzC,QAAQ,CAAC,EAAE,CAAC;IAAA;IAAjD0C,aAAa;IAAEC,kBAAkB;EACxC,iBAAwC3C,QAAQ,CAAC,EAAE,CAAC;IAAA;IAA7C4C,aAAa;IAAEC,cAAc;EACpC,iBAAwC7C,QAAQ,CAAC,IAAI,CAAC;IAAA;IAA/C8C,YAAY;IAAEC,eAAe;EACpC,iBAAsC/C,QAAQ,CAC5CuC,SAAS,CAACS,MAAM,IAAIT,SAAS,CAACU,aAAa,CAC5C;IAAA;IAFMC,aAAa;IAAEC,YAAY;EAIlC,kBAAyCnD,QAAQ,CAAC,KAAK,CAAC;IAAA;IAAjDoD,YAAY;IAAEC,gBAAgB;EACrC,kBAAiDrD,QAAQ,CAAC,IAAI,CAAC;IAAA;IAAxDsD,eAAe;IAAEC,qBAAqB;EAC7C,IAAMC,MAAM,GAAGrD,MAAM,EAAE;EAEvB,IAAMsD,aAAa,GAAGvD,OAAO,CAAC;IAAA,OAAMJ,KAAK,CAAC4D,QAAQ,CAACC,OAAO,CAACpC,QAAQ,CAAC;EAAA,GAAE,CACpEA,QAAQ,CACT,CAAC;EAEFtB,SAAS,CAAC,YAAM;IACd,IAAM2D,OAAO,GAAG,EAAE;IAClB,IAAMhB,aAAa,GAAG,EAAE;IAExB,IAAI,CAAChB,iBAAiB,EAAE;MACtBe,kBAAkB,CAAC,EAAE,CAAC;MACtBF,aAAa,CAAC,EAAE,CAAC;MACjBI,cAAc,CAACY,aAAa,CAAC;MAC7BV,eAAe,CAAC,IAAI,CAAC;MACrB;IACF;IAEAU,aAAa,CAACI,OAAO,CAAC,UAACC,KAAK,EAAEC,KAAK,EAAK;MACtC,IAAIrD,QAAQ,CAACoD,KAAK,CAAC,EAAE;QACnBF,OAAO,CAACI,IAAI,CAACrD,sBAAsB,CAACmD,KAAK,EAAEC,KAAK,CAAC,CAAC;MACpD,CAAC,MAAM;QACLnB,aAAa,CAACoB,IAAI,CAACF,KAAK,CAAC;MAC3B;IACF,CAAC,CAAC;IAEF,IAAMhB,YAAY,GAAG,IAAItC,YAAY,CAAC;MACpCS,MAAM,EAANA,MAAM;MACNC,OAAO,EAAPA,OAAO;MACPC,OAAO,EAAPA,OAAO;MACPC,SAAS,EAATA,SAAS;MACTC,MAAM,EAANA,MAAM;MACNC,QAAQ,EAARA;IACF,CAAC,CAAC;IAEFwB,YAAY,CAACmB,IAAI,CAACL,OAAO,CAAC;IAE1B,IAAMM,IAAI,GAAGtD,aAAa,CAACsC,aAAa,CAAC;IACzC,IAAMiB,IAAI,GAAGtD,aAAa,CAACqC,aAAa,EAAEgB,IAAI,EAAE/C,OAAO,CAAC;IACxD,IAAMqB,OAAO,GAAGM,YAAY,CAACsB,WAAW,CAACF,IAAI,EAAEC,IAAI,CAAC;IAEpD1B,aAAa,CAACD,OAAO,CAAC;IACtBK,cAAc,CAACD,aAAa,CAAC;IAC7BG,eAAe,CAACD,YAAY,CAAC;IAE7BR,eAAe,CAAC+B,OAAO,GAAGvB,YAAY;EACxC,CAAC,EAAE,CAACW,aAAa,EAAE7B,iBAAiB,CAAC,CAAC;EAEtC3B,SAAS,CAAC,YAAM;IACd,IAAI,CAACoC,aAAa,EAAE;IAEpB,IAAIe,YAAY,IAAIZ,OAAO,CAAC8B,MAAM,GAAG,CAAC,EAAE;MACtC,IAAIC,gBAAgB,GAAG,EAAE;MACzB,IAAIC,cAAc,GAAG,EAAE;MACvBhC,OAAO,CAACiC,GAAG,CAAC,UAACC,MAAM,EAAEC,CAAC,EAAK;QACzB,IAAID,MAAM,CAACE,UAAU,CAACC,OAAO,EAAE;UAC7BL,cAAc,GAAG1B,YAAY,CAACgC,SAAS,CACrCJ,MAAM,CAACE,UAAU,CAACG,UAAU,EAC5BC,QAAQ,CACT;QACH;QACA,IAAIC,SAAS,GAAGnE,cAAc,CAAC4D,MAAM,EAAEF,cAAc,EAAEhC,OAAO,EAAEmC,CAAC,CAAC;QAClEJ,gBAAgB,CAACP,IAAI,OAArBO,gBAAgB,qBAASU,SAAS,EAAC;MACrC,CAAC,CAAC;MAEFtC,kBAAkB,CAAC4B,gBAAgB,CAAC;IACtC,CAAC,MAAM;MACL5B,kBAAkB,CAAC,EAAE,CAAC;IACxB;EACF,CAAC,EAAE,CAACS,YAAY,EAAEZ,OAAO,CAAC,CAAC;EAE3B,IAAM0C,uBAAuB,GAAG,SAA1BA,uBAAuB,CAAIlC,MAAM,EAAK;IAC1C,IAAIF,YAAY,IAAIE,MAAM,EAAE;MAC1B,IAAMkB,IAAI,GAAGtD,aAAa,CAACoC,MAAM,CAAC;MAClC,IAAMmB,IAAI,GAAGtD,aAAa,CAACmC,MAAM,EAAEkB,IAAI,EAAE/C,OAAO,CAAC;MACjD,IAAMqB,QAAO,GAAGM,YAAY,CAACsB,WAAW,CAACF,IAAI,EAAEC,IAAI,CAAC;MACpD,IAAIjC,gBAAgB,IAAIiD,QAAQ,CAACC,EAAE,KAAK,KAAK,EAAE;QAC7CC,eAAe,CAACC,aAAa,CAACrD,mBAAmB,CAAC;MACpD;MACA,IAAIkC,IAAI,IAAI,EAAE,IAAI3B,QAAO,CAAC8B,MAAM,GAAG,CAAC,IAAIhB,eAAe,EAAE;QACvD,IAAIjB,aAAa,EAAEgB,gBAAgB,CAAC,IAAI,CAAC;MAC3C,CAAC,MAAM;QACL,IAAIhB,aAAa,EAAEgB,gBAAgB,CAAC,KAAK,CAAC;MAC5C;MACAZ,aAAa,CAACD,QAAO,CAAC;MACtBd,eAAe,CAACc,QAAO,CAAC;MACxBf,sBAAsB,CAACuB,MAAM,EAAER,QAAO,CAAC;MACvCW,YAAY,CAACH,MAAM,CAAC;IACtB,CAAC,MAAM;MACLvB,sBAAsB,CAACuB,MAAM,CAAC;IAChC;EACF,CAAC;EAED,IAAMuC,eAAe,GAAG,SAAlBA,eAAe,CAAIV,OAAO;IAAA,OAAK,YAAM;MACzC,IAAMtD,QAAQ,GAAGuB,YAAY,CAACgC,SAAS,CAACD,OAAO,CAACW,EAAE,EAAER,QAAQ,CAAC;MAC7DzB,qBAAqB,CAAChC,QAAQ,CAAC;MAE/B,IAAII,4BAA4B,EAAE;QAChCH,cAAc,CAACqD,OAAO,EAAEtD,QAAQ,CAAC;QACjC;MACF;MAEA,IAAMkE,WAAW,GAAGlE,QAAQ,CAACkD,GAAG,CAAC;QAAA,IAAGiB,QAAQ,SAARA,QAAQ;QAAA,OAAQ;UAClDC,QAAQ,EAAED,QAAQ,CAACD,WAAW,CAAC,CAAC,CAAC;UACjCG,SAAS,EAAEF,QAAQ,CAACD,WAAW,CAAC,CAAC;QACnC,CAAC;MAAA,CAAC,CAAC;MAEHjC,MAAM,CAACa,OAAO,CAACwB,gBAAgB,CAACJ,WAAW,EAAE;QAC3CK,WAAW,EAAEvD,SAAS,CAACuD;MACzB,CAAC,CAAC;MAEFtE,cAAc,CAACqD,OAAO,EAAEtD,QAAQ,CAAC;IACnC,CAAC;EAAA;EAED,OACE,MAAC,OAAO,kCACFgB,SAAS;IACb,GAAG,EAAE,aAACkC,GAAG,EAAK;MACZjB,MAAM,CAACa,OAAO,GAAGI,GAAG;MACpB,IAAIzD,KAAG,EAAEA,KAAG,CAACqD,OAAO,GAAGI,GAAG;MAC1BlC,SAAS,CAACiB,MAAM,CAACiB,GAAG,CAAC;IACvB,CAAE;IACF,sBAAsB,EAAES,uBAAwB;IAAA,WAE/C1C,OAAO,CAACiC,GAAG,CAAC,UAACC,MAAM;MAAA,OAClBA,MAAM,CAACE,UAAU,CAACmB,WAAW,KAAK,CAAC,GACjCtC,aAAa,CAACiB,MAAM,CAACE,UAAU,CAACb,KAAK,CAAC,GACpC,CAACX,YAAY,GACfjB,aAAa,GACXA,aAAa;QACX6D,OAAO,EAAET,eAAe,CAACb,MAAM,CAAC;QAChC7C,YAAY,EAAZA,YAAY;QACZC,gBAAgB,EAAhBA,gBAAgB;QAChBC,iBAAiB,EAAjBA;MAAiB,GACd2C,MAAM,EACT,GAEF,KAAC,aAAa,kCAERA,MAAM;QACV,OAAO,EAAEa,eAAe,CAACb,MAAM,CAAE;QACjC,YAAY,EACVnC,SAAS,CAAC0D,iBAAiB,KAAKvB,MAAM,CAACc,EAAE,GACrCjD,SAAS,CAAC2D,oBAAoB,GAC9BrE,YACL;QACD,gBAAgB,EAAEC,gBAAiB;QACnC,iBAAiB,EAAEC,iBAAkB;QACrC,iBAAiB,EAAEK;MAAkB,iBAVrBsC,MAAM,CAACc,EAAE,CAY5B,GACC,IAAI;IAAA,EACT,EACA5C,aAAa,EACbF,aAAa,CAAC+B,GAAG,CAAC,UAACC,MAAM,EAAK;MAC7B,OAAOjB,aAAa,CAACiB,MAAM,CAACX,KAAK,CAAC,GAC9BjE,KAAK,CAACqG,YAAY,CAAC1C,aAAa,CAACiB,MAAM,CAACX,KAAK,CAAC,EAAE;QAC9CqC,UAAU,oBAAO1B,MAAM;MACzB,CAAC,CAAC,GACF,IAAI;IACV,CAAC,CAAC,EACDhC,aAAa,CAAC+B,GAAG,CAAC,UAACC,MAAM,EAAEX,KAAK;MAAA,OAC/B,KAAC,QAAQ;QAEP,WAAW,EAAE,CAACW,MAAM,CAAC2B,WAAW,EAAE3B,MAAM,EAAEA,MAAM,CAAC2B,WAAW,CAAE;QAC9D,WAAW,EAAErE,eAAgB;QAC7B,WAAW,EAAE;MAAE,GAHV+B,KAAK,CAIV;IAAA,CACH,CAAC;EAAA,GACM;AAEd,CAAC,CACF;AAEDhD,gBAAgB,CAACuF,YAAY,GAAG;EAC9B1E,iBAAiB,EAAE,IAAI;EACvBS,aAAa,EAAE,IAAI;EACnBH,gBAAgB,EAAE,IAAI;EACtBP,4BAA4B,EAAE,KAAK;EACnCM,mBAAmB,EAAEoD,eAAe,CAACkB,OAAO,CAACC,MAAM;EACnDpE,iBAAiB,EAAE,KAAK;EAExBnB,MAAM,EAAEwF,UAAU,CAACC,GAAG,CAAC,QAAQ,CAAC,CAACC,KAAK,GAAG,IAAI;EAC7CzF,OAAO,EAAE,EAAE;EACXC,OAAO,EAAE,CAAC;EACVC,SAAS,EAAE,CAAC;EACZC,MAAM,EAAE,GAAG;EACXC,QAAQ,EAAE,EAAE;EAEZwE,WAAW,EAAE;IAAEc,GAAG,EAAE,EAAE;IAAEC,IAAI,EAAE,EAAE;IAAEC,KAAK,EAAE,EAAE;IAAEC,MAAM,EAAE;EAAG,CAAC;EAEzDlF,YAAY,EAAE,SAAS;EACvBC,gBAAgB,EAAE,SAAS;EAC3BE,eAAe,EAAE,SAAS;EAE1BP,sBAAsB,EAAE,kCAAM,CAAC,CAAC;EAChCD,cAAc,EAAE,0BAAM,CAAC,CAAC;EACxBE,eAAe,EAAE,2BAAM,CAAC,CAAC;EACzBY,eAAe,EAAE,CAAC,CAAC;EACnBkB,MAAM,EAAE,kBAAM,CAAC;AACjB,CAAC;AAED,eAAezD,IAAI,CAACgB,gBAAgB,CAAC"},"metadata":{},"sourceType":"module"}