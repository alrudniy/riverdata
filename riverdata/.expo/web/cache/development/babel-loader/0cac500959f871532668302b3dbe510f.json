{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport KDBush from 'kdbush';\nvar defaultOptions = {\n  minZoom: 0,\n  maxZoom: 16,\n  minPoints: 2,\n  radius: 40,\n  extent: 512,\n  nodeSize: 64,\n  log: false,\n\n  generateId: false,\n  reduce: null,\n\n  map: function map(props) {\n    return props;\n  }\n};\n\nvar fround = Math.fround || function (tmp) {\n  return function (x) {\n    tmp[0] = +x;\n    return tmp[0];\n  };\n}(new Float32Array(1));\nvar Supercluster = function () {\n  function Supercluster(options) {\n    _classCallCheck(this, Supercluster);\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  }\n  _createClass(Supercluster, [{\n    key: \"load\",\n    value: function load(points) {\n      var _this$options = this.options,\n        log = _this$options.log,\n        minZoom = _this$options.minZoom,\n        maxZoom = _this$options.maxZoom,\n        nodeSize = _this$options.nodeSize;\n      if (log) console.time('total time');\n      var timerId = \"prepare \" + points.length + \" points\";\n      if (log) console.time(timerId);\n      this.points = points;\n\n      var clusters = [];\n      for (var i = 0; i < points.length; i++) {\n        if (!points[i].geometry) continue;\n        clusters.push(createPointCluster(points[i], i));\n      }\n      this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) console.timeEnd(timerId);\n\n      for (var z = maxZoom; z >= minZoom; z--) {\n        var now = +Date.now();\n\n        clusters = this._cluster(clusters, z);\n        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n        if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n      }\n      if (log) console.timeEnd('total time');\n      return this;\n    }\n  }, {\n    key: \"getClusters\",\n    value: function getClusters(bbox, zoom) {\n      var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n      var minLat = Math.max(-90, Math.min(90, bbox[1]));\n      var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n      var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n      if (bbox[2] - bbox[0] >= 360) {\n        minLng = -180;\n        maxLng = 180;\n      } else if (minLng > maxLng) {\n        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n        return easternHem.concat(westernHem);\n      }\n      var tree = this.trees[this._limitZoom(zoom)];\n      var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n      var clusters = [];\n      for (var id of ids) {\n        var c = tree.points[id];\n        clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n      return clusters;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(clusterId) {\n      var originId = this._getOriginId(clusterId);\n      var originZoom = this._getOriginZoom(clusterId);\n      var errorMsg = 'No cluster with the specified id.';\n      var index = this.trees[originZoom];\n      if (!index) throw new Error(errorMsg);\n      var origin = index.points[originId];\n      if (!origin) throw new Error(errorMsg);\n      var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n      var ids = index.within(origin.x, origin.y, r);\n      var children = [];\n      for (var id of ids) {\n        var c = index.points[id];\n        if (c.parentId === clusterId) {\n          children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n      }\n      if (children.length === 0) throw new Error(errorMsg);\n      return children;\n    }\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves(clusterId, limit, offset) {\n      limit = limit || 10;\n      offset = offset || 0;\n      var leaves = [];\n      this._appendLeaves(leaves, clusterId, limit, offset, 0);\n      return leaves;\n    }\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y) {\n      var tree = this.trees[this._limitZoom(z)];\n      var z2 = Math.pow(2, z);\n      var _this$options2 = this.options,\n        extent = _this$options2.extent,\n        radius = _this$options2.radius;\n      var p = radius / extent;\n      var top = (y - p) / z2;\n      var bottom = (y + 1 + p) / z2;\n      var tile = {\n        features: []\n      };\n      this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n      if (x === 0) {\n        this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n      }\n      if (x === z2 - 1) {\n        this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n      }\n      return tile.features.length ? tile : null;\n    }\n  }, {\n    key: \"getClusterExpansionZoom\",\n    value: function getClusterExpansionZoom(clusterId) {\n      var expansionZoom = this._getOriginZoom(clusterId) - 1;\n      while (expansionZoom <= this.options.maxZoom) {\n        var children = this.getChildren(clusterId);\n        expansionZoom++;\n        if (children.length !== 1) break;\n        clusterId = children[0].properties.cluster_id;\n      }\n      return expansionZoom;\n    }\n  }, {\n    key: \"_appendLeaves\",\n    value: function _appendLeaves(result, clusterId, limit, offset, skipped) {\n      var children = this.getChildren(clusterId);\n      for (var child of children) {\n        var props = child.properties;\n        if (props && props.cluster) {\n          if (skipped + props.point_count <= offset) {\n            skipped += props.point_count;\n          } else {\n            skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n          }\n        } else if (skipped < offset) {\n          skipped++;\n        } else {\n          result.push(child);\n        }\n        if (result.length === limit) break;\n      }\n      return skipped;\n    }\n  }, {\n    key: \"_addTileFeatures\",\n    value: function _addTileFeatures(ids, points, x, y, z2, tile) {\n      for (var i of ids) {\n        var c = points[i];\n        var isCluster = c.numPoints;\n        var tags = void 0,\n          px = void 0,\n          py = void 0;\n        if (isCluster) {\n          tags = getClusterProperties(c);\n          px = c.x;\n          py = c.y;\n        } else {\n          var p = this.points[c.index];\n          tags = p.properties;\n          px = lngX(p.geometry.coordinates[0]);\n          py = latY(p.geometry.coordinates[1]);\n        }\n        var f = {\n          type: 1,\n          geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n          tags: tags\n        };\n\n        var id = void 0;\n        if (isCluster) {\n          id = c.id;\n        } else if (this.options.generateId) {\n          id = c.index;\n        } else if (this.points[c.index].id) {\n          id = this.points[c.index].id;\n        }\n        if (id !== undefined) f.id = id;\n        tile.features.push(f);\n      }\n    }\n  }, {\n    key: \"_limitZoom\",\n    value: function _limitZoom(z) {\n      return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n  }, {\n    key: \"_cluster\",\n    value: function _cluster(points, zoom) {\n      var clusters = [];\n      var _this$options3 = this.options,\n        radius = _this$options3.radius,\n        extent = _this$options3.extent,\n        reduce = _this$options3.reduce,\n        minPoints = _this$options3.minPoints;\n      var r = radius / (extent * Math.pow(2, zoom));\n\n      for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        if (p.zoom <= zoom) continue;\n        p.zoom = zoom;\n\n        var tree = this.trees[zoom + 1];\n        var neighborIds = tree.within(p.x, p.y, r);\n        var numPointsOrigin = p.numPoints || 1;\n        var numPoints = numPointsOrigin;\n\n        for (var neighborId of neighborIds) {\n          var b = tree.points[neighborId];\n          if (b.zoom > zoom) numPoints += b.numPoints || 1;\n        }\n\n        if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n          var wx = p.x * numPointsOrigin;\n          var wy = p.y * numPointsOrigin;\n          var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n          var id = (i << 5) + (zoom + 1) + this.points.length;\n          for (var _neighborId of neighborIds) {\n            var _b = tree.points[_neighborId];\n            if (_b.zoom <= zoom) continue;\n            _b.zoom = zoom;\n\n            var numPoints2 = _b.numPoints || 1;\n            wx += _b.x * numPoints2;\n            wy += _b.y * numPoints2;\n            _b.parentId = id;\n            if (reduce) {\n              if (!clusterProperties) clusterProperties = this._map(p, true);\n              reduce(clusterProperties, this._map(_b));\n            }\n          }\n          p.parentId = id;\n          clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n        } else {\n          clusters.push(p);\n          if (numPoints > 1) {\n            for (var _neighborId2 of neighborIds) {\n              var _b2 = tree.points[_neighborId2];\n              if (_b2.zoom <= zoom) continue;\n              _b2.zoom = zoom;\n              clusters.push(_b2);\n            }\n          }\n        }\n      }\n      return clusters;\n    }\n\n  }, {\n    key: \"_getOriginId\",\n    value:\n    function _getOriginId(clusterId) {\n      return clusterId - this.points.length >> 5;\n    }\n\n  }, {\n    key: \"_getOriginZoom\",\n    value:\n    function _getOriginZoom(clusterId) {\n      return (clusterId - this.points.length) % 32;\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(point, clone) {\n      if (point.numPoints) {\n        return clone ? extend({}, point.properties) : point.properties;\n      }\n      var original = this.points[point.index].properties;\n      var result = this.options.map(original);\n      return clone && result === original ? extend({}, result) : result;\n    }\n  }]);\n  return Supercluster;\n}();\nexport { Supercluster as default };\nfunction createCluster(x, y, id, numPoints, properties) {\n  return {\n    x: fround(x),\n    y: fround(y),\n    zoom: Infinity,\n    id: id,\n    parentId: -1,\n    numPoints: numPoints,\n    properties: properties\n  };\n}\nfunction createPointCluster(p, id) {\n  var _p$geometry$coordinat = _slicedToArray(p.geometry.coordinates, 2),\n    x = _p$geometry$coordinat[0],\n    y = _p$geometry$coordinat[1];\n  return {\n    x: fround(lngX(x)),\n    y: fround(latY(y)),\n    zoom: Infinity,\n    index: id,\n    parentId: -1\n  };\n}\n\nfunction getClusterJSON(cluster) {\n  return {\n    type: 'Feature',\n    id: cluster.id,\n    properties: getClusterProperties(cluster),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(cluster.x), yLat(cluster.y)]\n    }\n  };\n}\nfunction getClusterProperties(cluster) {\n  var count = cluster.numPoints;\n  var abbrev = count >= 10000 ? Math.round(count / 1000) + \"k\" : count >= 1000 ? Math.round(count / 100) / 10 + \"k\" : count;\n  return extend(extend({}, cluster.properties), {\n    cluster: true,\n    cluster_id: cluster.id,\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n}\n\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n  var sin = Math.sin(lat * Math.PI / 180);\n  var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n  var y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\nfunction extend(dest, src) {\n  for (var id in src) {\n    dest[id] = src[id];\n  }\n  return dest;\n}\nfunction getX(p) {\n  return p.x;\n}\nfunction getY(p) {\n  return p.y;\n}","map":{"version":3,"names":["KDBush","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","nodeSize","log","generateId","reduce","map","props","fround","Math","tmp","x","Float32Array","Supercluster","options","extend","Object","create","trees","Array","points","console","time","timerId","length","clusters","i","geometry","push","createPointCluster","getX","getY","timeEnd","z","now","Date","_cluster","bbox","zoom","minLng","minLat","max","min","maxLng","maxLat","easternHem","getClusters","westernHem","concat","tree","_limitZoom","ids","range","lngX","latY","id","c","numPoints","getClusterJSON","index","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","r","pow","within","y","children","parentId","limit","offset","leaves","_appendLeaves","z2","p","top","bottom","tile","features","_addTileFeatures","expansionZoom","getChildren","properties","cluster_id","result","skipped","child","cluster","point_count","isCluster","tags","px","py","getClusterProperties","coordinates","f","type","round","undefined","floor","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","createCluster","point","clone","original","Infinity","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","exp","dest","src"],"sources":["C:/Users/subte/RD2/riverdata/riverdata/node_modules/react-native-map-clustering/node_modules/supercluster/index.js"],"sourcesContent":["\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}